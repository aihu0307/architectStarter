<h1>3.1.3垃圾回收</h1>

　　程序在执行的过程中会不断的申请分配新的内存，当达到一定极限后就会触发垃圾回收，那么垃圾是怎么回收的呢？

　　首先要使用回收算法判定哪些内存是要回收，哪些不能回收，比如引用计数法，当这个对象被引用的时候，计数加一，删除引用的时候减一，触发垃圾回收时判断对象的引用计数为零的被回收。

　　单纯的内存回收会导致大量的内存碎片，所以回收之后还需要整理一下内存，这就有了标记-整理（标记-删除，复制请自己学习）。它的过程如下：

　　1、从根节点开始，标记所有被引用的对象

　　2、遍历整个堆，清除未被标记的对象，同时将被标记的对象按顺序压缩到堆的一块区域中。

　　由于回收需要遍历所有对象，并暂停整个程序运行，经常性的垃圾回收(full gc)会影响整个程序的性能，于是便又有了分代回收。

　　分代回收是把内存分为新生代，老年代，永久代3个部分，新生代又分成了1个Eden和2个Survivor，一个对象新创建的时候，会放在Eden中，当Eden满了以后，将存活的对象复制到一个Survivor1中，当Survivor1满了后，此区还存活的对象会复制到Survivor2中，同时清空了Survivor1，之后Eden复制过来的对象将到Survivor2中，当Survivor2满了以后，会将之前从Survivor1复制过来的对象移到老年代中，注意2个Survivor总有一个是空的，另一个中可能同时存放着从Eden过来的对象和另一个Survivor过来的对象，Survivor可以配置多个。Eden和Survivor中进行的gc又称为minar gc，老年代满了后触发的gc成为major gc，而整个堆的回收又成为full gc。

　　Full gc触发条件主要有以下几种情况：

　　1、调用System.gc()时；

　　2、老年代空间不足，不足以容纳从Survivor区过来的大对象时；

　　3、方法区空间不足时；

　　4、在minar gc的时候，统计发现即将移到老年代的对象大小大于老年代当前可以容纳的大小，这时minar gc转为full gc。

　　5、老年代连续的空间不足时，比如老年代有500k，其中连续可用的只有100k，当下要分配一个200k的对象时，会触发full gc。